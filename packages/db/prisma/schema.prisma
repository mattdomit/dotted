generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// Users & Auth
// ============================================

enum UserRole {
  CONSUMER
  RESTAURANT_OWNER
  SUPPLIER
  ADMIN
}

model User {
  id                 String   @id @default(uuid())
  email              String   @unique
  name               String
  role               UserRole @default(CONSUMER)
  passwordHash       String?
  googleId           String?  @unique
  avatarUrl          String?
  emailVerified      Boolean  @default(false)
  phoneNumber        String?
  dietaryPreferences Json     @default("[]")
  bio                String?  @db.Text
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relations
  votes             Vote[]
  orders            Order[]
  restaurant        Restaurant?
  supplier          Supplier?
  zoneMemberships   ZoneMembership[]
  reviews           Review[]
  notifications     Notification[]
  verificationCodes VerificationCode[]
  reviewReplies     ReviewReply[]
  reviewVotes       ReviewVote[]
  zonePosts         ZonePost[]
  postComments      PostComment[]
  postLikes         PostLike[]

  @@map("users")
}

// ============================================
// Verification
// ============================================

enum VerificationType {
  EMAIL
  SMS
}

model VerificationCode {
  id         String           @id @default(uuid())
  userId     String
  code       String
  type       VerificationType
  expiresAt  DateTime
  verifiedAt DateTime?
  createdAt  DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("verification_codes")
}

// ============================================
// Geography
// ============================================

model Zone {
  id               String   @id @default(uuid())
  name             String
  slug             String   @unique
  city             String
  state            String
  // PostGIS boundary stored as GeoJSON string (use raw SQL for spatial queries)
  boundaryGeoJson  String?  @db.Text
  isActive         Boolean  @default(true)
  dailyCycleConfig Json     @default("{}")
  maxPricePerPlate Float?
  preferredCuisines Json    @default("[]")
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  memberships  ZoneMembership[]
  dailyCycles  DailyCycle[]
  restaurants  Restaurant[]
  suppliers    Supplier[]
  zonePosts    ZonePost[]

  @@map("zones")
}

model ZoneMembership {
  id       String   @id @default(uuid())
  userId   String
  zoneId   String
  joinedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  zone Zone @relation(fields: [zoneId], references: [id], onDelete: Cascade)

  @@unique([userId, zoneId])
  @@map("zone_memberships")
}

// ============================================
// Daily Cycle
// ============================================

enum CycleStatus {
  SUGGESTING
  VOTING
  BIDDING
  SOURCING
  ORDERING
  COMPLETED
  CANCELLED
}

model DailyCycle {
  id            String      @id @default(uuid())
  zoneId        String
  date          DateTime    @db.Date
  status        CycleStatus @default(SUGGESTING)
  winningDishId String?
  winningBidId  String?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relations
  zone           Zone            @relation(fields: [zoneId], references: [id])
  dishes         Dish[]
  votes          Vote[]
  bids           Bid[]
  purchaseOrders PurchaseOrder[]
  orders         Order[]

  @@unique([zoneId, date])
  @@map("daily_cycles")
}

// ============================================
// Dishes
// ============================================

model Dish {
  id            String   @id @default(uuid())
  dailyCycleId  String
  name          String
  description   String   @db.Text
  cuisine       String
  imageUrl      String?
  recipeSpec    Json     @default("{}")
  estimatedCost Float
  voteCount     Int      @default(0)
  aiPromptUsed  String?  @db.Text
  createdAt     DateTime @default(now())

  // Relations
  dailyCycle  DailyCycle   @relation(fields: [dailyCycleId], references: [id], onDelete: Cascade)
  ingredients Ingredient[]
  votes       Vote[]
  bids        Bid[]
  orderItems  OrderItem[]

  @@map("dishes")
}

// ============================================
// Ingredients
// ============================================

model Ingredient {
  id                  String  @id @default(uuid())
  dishId              String
  name                String
  quantity            Float
  unit                String
  category            String
  preferredSupplierId String?
  substitutes         Json    @default("[]")

  // Relations
  dish Dish @relation(fields: [dishId], references: [id], onDelete: Cascade)

  @@map("ingredients")
}

// ============================================
// Voting
// ============================================

model Vote {
  id           String   @id @default(uuid())
  userId       String
  dishId       String
  dailyCycleId String
  createdAt    DateTime @default(now())

  // Relations
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  dish       Dish       @relation(fields: [dishId], references: [id], onDelete: Cascade)
  dailyCycle DailyCycle @relation(fields: [dailyCycleId], references: [id], onDelete: Cascade)

  @@unique([userId, dailyCycleId])
  @@map("votes")
}

// ============================================
// Restaurants & Bidding
// ============================================

model Restaurant {
  id          String  @id @default(uuid())
  ownerId     String  @unique
  name        String
  address     String
  latitude    Float?
  longitude   Float?
  rating      Float   @default(0)
  capacity    Int
  description String? @db.Text
  imageUrl    String?
  isVerified  Boolean @default(false)
  zoneId      String

  // Enrollment fields
  ownerFullName          String?
  businessLicenseNumber  String?
  taxId                  String?
  phone                  String?
  email                  String?
  city                   String?
  state                  String?
  zipCode                String?
  cuisineTypes           Json?     @default("[]")
  kitchenCapacity        Int?
  healthPermitNumber     String?
  insurancePolicyNumber  String?
  yearsInOperation       Int?
  website                String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  owner   User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  zone    Zone     @relation(fields: [zoneId], references: [id])
  bids    Bid[]
  orders  Order[]
  reviews Review[]

  @@map("restaurants")
}

enum BidStatus {
  PENDING
  WON
  LOST
}

model Bid {
  id                 String    @id @default(uuid())
  restaurantId       String
  dailyCycleId       String
  dishId             String
  pricePerPlate      Float
  prepTime           Int
  maxCapacity        Int
  serviceFeeAccepted Boolean   @default(true)
  score              Float?
  status             BidStatus @default(PENDING)
  createdAt          DateTime  @default(now())

  // Relations
  restaurant Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  dailyCycle DailyCycle @relation(fields: [dailyCycleId], references: [id], onDelete: Cascade)
  dish       Dish       @relation(fields: [dishId], references: [id], onDelete: Cascade)

  @@unique([restaurantId, dailyCycleId])
  @@map("bids")
}

// ============================================
// Suppliers & Inventory
// ============================================

model Supplier {
  id              String  @id @default(uuid())
  ownerId         String  @unique
  businessName    String
  address         String
  latitude        Float?
  longitude       Float?
  certifications  Json    @default("[]")
  rating          Float   @default(0)
  isVerified      Boolean @default(false)
  zoneId          String
  onTimeRate      Float   @default(0)
  qualityScore    Float   @default(0)
  fulfillmentRate Float   @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  owner          User                @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  zone           Zone                @relation(fields: [zoneId], references: [id])
  inventory      SupplierInventory[]
  purchaseOrders PurchaseOrder[]

  @@map("suppliers")
}

model SupplierInventory {
  id                String    @id @default(uuid())
  supplierId        String
  ingredientName    String
  category          String
  unit              String
  pricePerUnit      Float
  quantityAvailable Float
  harvestDate       DateTime?
  isOrganic         Boolean   @default(false)
  expiresAt         DateTime?
  updatedAt         DateTime  @updatedAt

  // Relations
  supplier           Supplier            @relation(fields: [supplierId], references: [id], onDelete: Cascade)
  purchaseOrderItems PurchaseOrderItem[]

  @@map("supplier_inventory")
}

// ============================================
// Purchase Orders
// ============================================

enum PurchaseOrderStatus {
  PENDING
  CONFIRMED
  SHIPPED
  DELIVERED
}

model PurchaseOrder {
  id                 String              @id @default(uuid())
  dailyCycleId       String
  supplierId         String
  status             PurchaseOrderStatus @default(PENDING)
  totalCost          Float
  deliveryEta        DateTime?
  deliveryNotes      String?             @db.Text
  actualDeliveryTime DateTime?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt

  // Relations
  dailyCycle        DailyCycle          @relation(fields: [dailyCycleId], references: [id], onDelete: Cascade)
  supplier          Supplier            @relation(fields: [supplierId], references: [id])
  items             PurchaseOrderItem[]
  deliveryTracking  DeliveryTracking[]

  @@map("purchase_orders")
}

model PurchaseOrderItem {
  id              String @id @default(uuid())
  purchaseOrderId String
  inventoryItemId String
  quantity        Float
  unitPrice       Float

  // Relations
  purchaseOrder PurchaseOrder     @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  inventoryItem SupplierInventory @relation(fields: [inventoryItemId], references: [id])

  @@map("purchase_order_items")
}

// ============================================
// Delivery Tracking
// ============================================

enum DeliveryStatus {
  DISPATCHED
  IN_TRANSIT
  ARRIVED
  DELIVERED
  FAILED
}

model DeliveryTracking {
  id               String         @id @default(uuid())
  purchaseOrderId  String
  status           DeliveryStatus
  latitude         Float?
  longitude        Float?
  note             String?        @db.Text
  estimatedArrival DateTime?
  createdAt        DateTime       @default(now())

  purchaseOrder PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)

  @@map("delivery_tracking")
}

// ============================================
// Consumer Orders
// ============================================

enum OrderStatus {
  PENDING
  CONFIRMED
  READY
  PICKED_UP
  DELIVERED
  CANCELLED
  REFUNDED
}

enum FulfillmentType {
  PICKUP
  DELIVERY
}

model Order {
  id              String          @id @default(uuid())
  userId          String
  dailyCycleId    String
  restaurantId    String
  quantity        Int
  totalPrice      Float
  status          OrderStatus     @default(PENDING)
  fulfillmentType FulfillmentType @default(PICKUP)
  stripePaymentId String?
  stripeSessionId String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Relations
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  dailyCycle DailyCycle  @relation(fields: [dailyCycleId], references: [id])
  restaurant Restaurant  @relation(fields: [restaurantId], references: [id])
  items      OrderItem[]
  review     Review?

  @@map("orders")
}

model OrderItem {
  id       String @id @default(uuid())
  orderId  String
  dishId   String
  quantity Int
  price    Float

  // Relations
  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  dish  Dish  @relation(fields: [dishId], references: [id])

  @@map("order_items")
}

// ============================================
// Reviews
// ============================================

model Review {
  id           String   @id @default(uuid())
  userId       String
  restaurantId String
  orderId      String?  @unique
  rating       Int
  title        String
  body         String   @db.Text
  imageUrls    Json     @default("[]")
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  user       User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  restaurant Restaurant    @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  order      Order?        @relation(fields: [orderId], references: [id])
  replies    ReviewReply[]
  votes      ReviewVote[]

  @@unique([userId, orderId])
  @@map("reviews")
}

model ReviewReply {
  id        String   @id @default(uuid())
  reviewId  String
  userId    String
  body      String   @db.Text
  createdAt DateTime @default(now())

  review Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("review_replies")
}

model ReviewVote {
  id       String  @id @default(uuid())
  reviewId String
  userId   String
  helpful  Boolean

  review Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([reviewId, userId])
  @@map("review_votes")
}

// ============================================
// Community Feed
// ============================================

model ZonePost {
  id        String   @id @default(uuid())
  zoneId    String
  userId    String
  body      String   @db.Text
  imageUrl  String?
  createdAt DateTime @default(now())

  zone     Zone          @relation(fields: [zoneId], references: [id], onDelete: Cascade)
  user     User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  comments PostComment[]
  likes    PostLike[]

  @@index([zoneId, createdAt])
  @@map("zone_posts")
}

model PostComment {
  id        String   @id @default(uuid())
  postId    String
  userId    String
  body      String   @db.Text
  parentId  String?
  createdAt DateTime @default(now())

  post   ZonePost     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user   User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent PostComment? @relation("CommentThread", fields: [parentId], references: [id])
  children PostComment[] @relation("CommentThread")

  @@map("post_comments")
}

model PostLike {
  id     String @id @default(uuid())
  postId String
  userId String

  post ZonePost @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@map("post_likes")
}

// ============================================
// Notifications
// ============================================

model Notification {
  id        String    @id @default(uuid())
  userId    String
  type      String    // ORDER_CONFIRMED, BID_WON, CYCLE_PHASE
  title     String
  body      String    @db.Text
  channel   String    // EMAIL, SMS, IN_APP
  status    String    @default("PENDING")
  metadata  Json      @default("{}")
  readAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@map("notifications")
}
